{"ast":null,"code":"var _jsxFileName = \"/Users/claudiu/Desktop/pe foc de lemne/frontend/src/context/AuthContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport api from '../services/api';\n\n// Initial state\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialState = {\n  isAuthenticated: false,\n  user: null,\n  isLoading: true,\n  error: null,\n  tokens: null\n};\n\n// Action types\nconst AUTH_ACTIONS = {\n  LOGIN_START: 'LOGIN_START',\n  LOGIN_SUCCESS: 'LOGIN_SUCCESS',\n  LOGIN_FAILURE: 'LOGIN_FAILURE',\n  LOGOUT: 'LOGOUT',\n  REFRESH_TOKEN_SUCCESS: 'REFRESH_TOKEN_SUCCESS',\n  REFRESH_TOKEN_FAILURE: 'REFRESH_TOKEN_FAILURE',\n  SET_LOADING: 'SET_LOADING',\n  CLEAR_ERROR: 'CLEAR_ERROR',\n  SET_AUTH_DATA: 'SET_AUTH_DATA'\n};\n\n// Reducer\nconst authReducer = (state, action) => {\n  switch (action.type) {\n    case AUTH_ACTIONS.LOGIN_START:\n      return {\n        ...state,\n        isLoading: true,\n        error: null\n      };\n    case AUTH_ACTIONS.LOGIN_SUCCESS:\n      return {\n        ...state,\n        isAuthenticated: true,\n        user: action.payload.user,\n        tokens: action.payload.tokens,\n        isLoading: false,\n        error: null\n      };\n    case AUTH_ACTIONS.LOGIN_FAILURE:\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        tokens: null,\n        isLoading: false,\n        error: action.payload.error\n      };\n    case AUTH_ACTIONS.LOGOUT:\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        tokens: null,\n        isLoading: false,\n        error: null\n      };\n    case AUTH_ACTIONS.REFRESH_TOKEN_SUCCESS:\n      return {\n        ...state,\n        tokens: action.payload.tokens,\n        error: null\n      };\n    case AUTH_ACTIONS.REFRESH_TOKEN_FAILURE:\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        tokens: null,\n        error: action.payload.error\n      };\n    case AUTH_ACTIONS.SET_LOADING:\n      return {\n        ...state,\n        isLoading: action.payload.loading\n      };\n    case AUTH_ACTIONS.CLEAR_ERROR:\n      return {\n        ...state,\n        error: null\n      };\n    case AUTH_ACTIONS.SET_AUTH_DATA:\n      return {\n        ...state,\n        isAuthenticated: true,\n        user: action.payload.user,\n        tokens: action.payload.tokens,\n        isLoading: false,\n        error: null\n      };\n    default:\n      return state;\n  }\n};\n\n// Create context\nconst AuthContext = /*#__PURE__*/createContext();\n\n// Storage keys\nconst STORAGE_KEYS = {\n  ACCESS_TOKEN: 'auth_access_token',\n  REFRESH_TOKEN: 'auth_refresh_token',\n  USER_DATA: 'auth_user_data'\n};\n\n// AuthProvider component\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // Token management utilities\n  const setTokensInStorage = tokens => {\n    if (tokens !== null && tokens !== void 0 && tokens.access_token) {\n      localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);\n    }\n    if (tokens !== null && tokens !== void 0 && tokens.refresh_token) {\n      localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);\n    }\n  };\n  const clearTokensFromStorage = () => {\n    localStorage.removeItem(STORAGE_KEYS.ACCESS_TOKEN);\n    localStorage.removeItem(STORAGE_KEYS.REFRESH_TOKEN);\n    localStorage.removeItem(STORAGE_KEYS.USER_DATA);\n  };\n  const getTokenFromStorage = () => {\n    return localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);\n  };\n  const getRefreshTokenFromStorage = () => {\n    return localStorage.getItem(STORAGE_KEYS.REFRESH_TOKEN);\n  };\n  const setUserDataInStorage = userData => {\n    localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(userData));\n  };\n  const getUserDataFromStorage = () => {\n    const userData = localStorage.getItem(STORAGE_KEYS.USER_DATA);\n    return userData ? JSON.parse(userData) : null;\n  };\n\n  // Create authenticated API instance\n  const createAuthenticatedApi = token => {\n    const authApi = api.create();\n    authApi.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    return authApi;\n  };\n\n  // Login function\n  const login = async credentials => {\n    dispatch({\n      type: AUTH_ACTIONS.LOGIN_START\n    });\n    try {\n      const response = await api.post('/auth/admin/login', {\n        username: credentials.username,\n        password: credentials.password\n      });\n      if (response.data.success) {\n        const {\n          user,\n          tokens\n        } = response.data.data;\n\n        // Store tokens and user data\n        setTokensInStorage(tokens);\n        setUserDataInStorage(user);\n        dispatch({\n          type: AUTH_ACTIONS.LOGIN_SUCCESS,\n          payload: {\n            user,\n            tokens\n          }\n        });\n        return {\n          success: true,\n          message: response.data.message\n        };\n      } else {\n        var _response$data$error;\n        const error = ((_response$data$error = response.data.error) === null || _response$data$error === void 0 ? void 0 : _response$data$error.message) || 'Eroare la autentificare';\n        dispatch({\n          type: AUTH_ACTIONS.LOGIN_FAILURE,\n          payload: {\n            error\n          }\n        });\n        return {\n          success: false,\n          error\n        };\n      }\n    } catch (error) {\n      var _error$response, _error$response$data, _error$response$data$, _error$response2, _error$response2$data;\n      const errorMessage = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : (_error$response$data$ = _error$response$data.error) === null || _error$response$data$ === void 0 ? void 0 : _error$response$data$.message) || ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Eroare de rețea. Verificați conexiunea.';\n      dispatch({\n        type: AUTH_ACTIONS.LOGIN_FAILURE,\n        payload: {\n          error: errorMessage\n        }\n      });\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  };\n\n  // Logout function\n  const logout = async () => {\n    const token = getTokenFromStorage();\n    try {\n      if (token) {\n        // Call logout endpoint to invalidate token on server\n        const authApi = createAuthenticatedApi(token);\n        await authApi.post('/auth/admin/logout');\n      }\n    } catch (error) {\n      console.warn('Logout API call failed:', error.message);\n      // Continue with client-side logout even if server call fails\n    }\n\n    // Clear client-side data\n    clearTokensFromStorage();\n    dispatch({\n      type: AUTH_ACTIONS.LOGOUT\n    });\n  };\n\n  // Refresh token function\n  const refreshToken = async () => {\n    const refresh_token = getRefreshTokenFromStorage();\n    if (!refresh_token) {\n      dispatch({\n        type: AUTH_ACTIONS.REFRESH_TOKEN_FAILURE,\n        payload: {\n          error: 'Nu există token de reînnoire'\n        }\n      });\n      return false;\n    }\n    try {\n      const response = await api.post('/auth/admin/refresh', {\n        refresh_token\n      });\n      if (response.data.success) {\n        const tokens = response.data.data;\n        setTokensInStorage(tokens);\n        dispatch({\n          type: AUTH_ACTIONS.REFRESH_TOKEN_SUCCESS,\n          payload: {\n            tokens\n          }\n        });\n        return true;\n      } else {\n        var _response$data$error2;\n        clearTokensFromStorage();\n        dispatch({\n          type: AUTH_ACTIONS.REFRESH_TOKEN_FAILURE,\n          payload: {\n            error: ((_response$data$error2 = response.data.error) === null || _response$data$error2 === void 0 ? void 0 : _response$data$error2.message) || 'Token invalid'\n          }\n        });\n        return false;\n      }\n    } catch (error) {\n      clearTokensFromStorage();\n      dispatch({\n        type: AUTH_ACTIONS.REFRESH_TOKEN_FAILURE,\n        payload: {\n          error: 'Eroare la reînnoire token'\n        }\n      });\n      return false;\n    }\n  };\n\n  // Verify token function\n  const verifyToken = async token => {\n    try {\n      const authApi = createAuthenticatedApi(token);\n      const response = await authApi.post('/auth/admin/verify');\n      return response.data.success && response.data.data.valid;\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // Check authentication status\n  const checkAuthStatus = async () => {\n    dispatch({\n      type: AUTH_ACTIONS.SET_LOADING,\n      payload: {\n        loading: true\n      }\n    });\n    const token = getTokenFromStorage();\n    const userData = getUserDataFromStorage();\n    if (!token || !userData) {\n      dispatch({\n        type: AUTH_ACTIONS.SET_LOADING,\n        payload: {\n          loading: false\n        }\n      });\n      return;\n    }\n\n    // Verify token is still valid\n    const isValid = await verifyToken(token);\n    if (isValid) {\n      // Token is valid, restore authentication state\n      dispatch({\n        type: AUTH_ACTIONS.SET_AUTH_DATA,\n        payload: {\n          user: userData,\n          tokens: {\n            access_token: token,\n            refresh_token: getRefreshTokenFromStorage()\n          }\n        }\n      });\n    } else {\n      // Token is invalid, try to refresh\n      const refreshed = await refreshToken();\n      if (!refreshed) {\n        // Refresh failed, clear everything\n        clearTokensFromStorage();\n        dispatch({\n          type: AUTH_ACTIONS.LOGOUT\n        });\n      } else {\n        // Refresh succeeded, restore state with updated tokens\n        dispatch({\n          type: AUTH_ACTIONS.SET_AUTH_DATA,\n          payload: {\n            user: userData,\n            tokens: {\n              access_token: getTokenFromStorage(),\n              refresh_token: getRefreshTokenFromStorage()\n            }\n          }\n        });\n      }\n    }\n    dispatch({\n      type: AUTH_ACTIONS.SET_LOADING,\n      payload: {\n        loading: false\n      }\n    });\n  };\n\n  // Clear error function\n  const clearError = () => {\n    dispatch({\n      type: AUTH_ACTIONS.CLEAR_ERROR\n    });\n  };\n\n  // Get current access token\n  const getToken = () => {\n    var _state$tokens;\n    return ((_state$tokens = state.tokens) === null || _state$tokens === void 0 ? void 0 : _state$tokens.access_token) || getTokenFromStorage();\n  };\n\n  // Check if user has admin role\n  const isAdmin = () => {\n    var _state$user;\n    return ((_state$user = state.user) === null || _state$user === void 0 ? void 0 : _state$user.role) === 'admin';\n  };\n\n  // Protected route helper\n  const requireAuth = () => {\n    return state.isAuthenticated && isAdmin();\n  };\n\n  // Setup axios interceptor for automatic token attachment\n  useEffect(() => {\n    const requestInterceptor = api.interceptors.request.use(config => {\n      var _config$url;\n      const token = getToken();\n      if (token && (_config$url = config.url) !== null && _config$url !== void 0 && _config$url.includes('/admin/')) {\n        config.headers.Authorization = `Bearer ${token}`;\n      }\n      return config;\n    }, error => Promise.reject(error));\n    const responseInterceptor = api.interceptors.response.use(response => response, async error => {\n      var _error$response3, _originalRequest$url;\n      const originalRequest = error.config;\n\n      // Handle 401 errors for admin routes\n      if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) === 401 && (_originalRequest$url = originalRequest.url) !== null && _originalRequest$url !== void 0 && _originalRequest$url.includes('/admin/') && !originalRequest._retry) {\n        originalRequest._retry = true;\n\n        // Try to refresh token\n        const refreshed = await refreshToken();\n        if (refreshed) {\n          // Retry original request with new token\n          const newToken = getTokenFromStorage();\n          originalRequest.headers.Authorization = `Bearer ${newToken}`;\n          return api(originalRequest);\n        } else {\n          // Refresh failed, logout user\n          logout();\n        }\n      }\n      return Promise.reject(error);\n    });\n\n    // Cleanup interceptors on unmount\n    return () => {\n      api.interceptors.request.eject(requestInterceptor);\n      api.interceptors.response.eject(responseInterceptor);\n    };\n  }, [state.tokens]);\n\n  // Check authentication status on component mount\n  useEffect(() => {\n    checkAuthStatus();\n  }, []);\n  const contextValue = {\n    // State\n    isAuthenticated: state.isAuthenticated,\n    user: state.user,\n    isLoading: state.isLoading,\n    error: state.error,\n    tokens: state.tokens,\n    // Actions\n    login,\n    logout,\n    refreshToken,\n    verifyToken,\n    checkAuthStatus,\n    clearError,\n    // Utilities\n    getToken,\n    isAdmin,\n    requireAuth\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 433,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use auth context\n_s(AuthProvider, \"GUSXxL/WUElrtHc/X73NyHNRMdw=\");\n_c = AuthProvider;\nexport const useAuth = () => {\n  _s2();\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n_s2(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default AuthContext;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","api","jsxDEV","_jsxDEV","initialState","isAuthenticated","user","isLoading","error","tokens","AUTH_ACTIONS","LOGIN_START","LOGIN_SUCCESS","LOGIN_FAILURE","LOGOUT","REFRESH_TOKEN_SUCCESS","REFRESH_TOKEN_FAILURE","SET_LOADING","CLEAR_ERROR","SET_AUTH_DATA","authReducer","state","action","type","payload","loading","AuthContext","STORAGE_KEYS","ACCESS_TOKEN","REFRESH_TOKEN","USER_DATA","AuthProvider","children","_s","dispatch","setTokensInStorage","access_token","localStorage","setItem","refresh_token","clearTokensFromStorage","removeItem","getTokenFromStorage","getItem","getRefreshTokenFromStorage","setUserDataInStorage","userData","JSON","stringify","getUserDataFromStorage","parse","createAuthenticatedApi","token","authApi","create","defaults","headers","common","login","credentials","response","post","username","password","data","success","message","_response$data$error","_error$response","_error$response$data","_error$response$data$","_error$response2","_error$response2$data","errorMessage","logout","console","warn","refreshToken","_response$data$error2","verifyToken","valid","checkAuthStatus","isValid","refreshed","clearError","getToken","_state$tokens","isAdmin","_state$user","role","requireAuth","requestInterceptor","interceptors","request","use","config","_config$url","url","includes","Authorization","Promise","reject","responseInterceptor","_error$response3","_originalRequest$url","originalRequest","status","_retry","newToken","eject","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAuth","_s2","context","Error","$RefreshReg$"],"sources":["/Users/claudiu/Desktop/pe foc de lemne/frontend/src/context/AuthContext.jsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport api from '../services/api';\n\n// Initial state\nconst initialState = {\n  isAuthenticated: false,\n  user: null,\n  isLoading: true,\n  error: null,\n  tokens: null\n};\n\n// Action types\nconst AUTH_ACTIONS = {\n  LOGIN_START: 'LOGIN_START',\n  LOGIN_SUCCESS: 'LOGIN_SUCCESS',\n  LOGIN_FAILURE: 'LOGIN_FAILURE',\n  LOGOUT: 'LOGOUT',\n  REFRESH_TOKEN_SUCCESS: 'REFRESH_TOKEN_SUCCESS',\n  REFRESH_TOKEN_FAILURE: 'REFRESH_TOKEN_FAILURE',\n  SET_LOADING: 'SET_LOADING',\n  CLEAR_ERROR: 'CLEAR_ERROR',\n  SET_AUTH_DATA: 'SET_AUTH_DATA'\n};\n\n// Reducer\nconst authReducer = (state, action) => {\n  switch (action.type) {\n    case AUTH_ACTIONS.LOGIN_START:\n      return {\n        ...state,\n        isLoading: true,\n        error: null\n      };\n    \n    case AUTH_ACTIONS.LOGIN_SUCCESS:\n      return {\n        ...state,\n        isAuthenticated: true,\n        user: action.payload.user,\n        tokens: action.payload.tokens,\n        isLoading: false,\n        error: null\n      };\n    \n    case AUTH_ACTIONS.LOGIN_FAILURE:\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        tokens: null,\n        isLoading: false,\n        error: action.payload.error\n      };\n    \n    case AUTH_ACTIONS.LOGOUT:\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        tokens: null,\n        isLoading: false,\n        error: null\n      };\n    \n    case AUTH_ACTIONS.REFRESH_TOKEN_SUCCESS:\n      return {\n        ...state,\n        tokens: action.payload.tokens,\n        error: null\n      };\n    \n    case AUTH_ACTIONS.REFRESH_TOKEN_FAILURE:\n      return {\n        ...state,\n        isAuthenticated: false,\n        user: null,\n        tokens: null,\n        error: action.payload.error\n      };\n    \n    case AUTH_ACTIONS.SET_LOADING:\n      return {\n        ...state,\n        isLoading: action.payload.loading\n      };\n    \n    case AUTH_ACTIONS.CLEAR_ERROR:\n      return {\n        ...state,\n        error: null\n      };\n    \n    case AUTH_ACTIONS.SET_AUTH_DATA:\n      return {\n        ...state,\n        isAuthenticated: true,\n        user: action.payload.user,\n        tokens: action.payload.tokens,\n        isLoading: false,\n        error: null\n      };\n    \n    default:\n      return state;\n  }\n};\n\n// Create context\nconst AuthContext = createContext();\n\n// Storage keys\nconst STORAGE_KEYS = {\n  ACCESS_TOKEN: 'auth_access_token',\n  REFRESH_TOKEN: 'auth_refresh_token',\n  USER_DATA: 'auth_user_data'\n};\n\n// AuthProvider component\nexport const AuthProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  // Token management utilities\n  const setTokensInStorage = (tokens) => {\n    if (tokens?.access_token) {\n      localStorage.setItem(STORAGE_KEYS.ACCESS_TOKEN, tokens.access_token);\n    }\n    if (tokens?.refresh_token) {\n      localStorage.setItem(STORAGE_KEYS.REFRESH_TOKEN, tokens.refresh_token);\n    }\n  };\n\n  const clearTokensFromStorage = () => {\n    localStorage.removeItem(STORAGE_KEYS.ACCESS_TOKEN);\n    localStorage.removeItem(STORAGE_KEYS.REFRESH_TOKEN);\n    localStorage.removeItem(STORAGE_KEYS.USER_DATA);\n  };\n\n  const getTokenFromStorage = () => {\n    return localStorage.getItem(STORAGE_KEYS.ACCESS_TOKEN);\n  };\n\n  const getRefreshTokenFromStorage = () => {\n    return localStorage.getItem(STORAGE_KEYS.REFRESH_TOKEN);\n  };\n\n  const setUserDataInStorage = (userData) => {\n    localStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(userData));\n  };\n\n  const getUserDataFromStorage = () => {\n    const userData = localStorage.getItem(STORAGE_KEYS.USER_DATA);\n    return userData ? JSON.parse(userData) : null;\n  };\n\n  // Create authenticated API instance\n  const createAuthenticatedApi = (token) => {\n    const authApi = api.create();\n    authApi.defaults.headers.common['Authorization'] = `Bearer ${token}`;\n    return authApi;\n  };\n\n  // Login function\n  const login = async (credentials) => {\n    dispatch({ type: AUTH_ACTIONS.LOGIN_START });\n\n    try {\n      const response = await api.post('/auth/admin/login', {\n        username: credentials.username,\n        password: credentials.password\n      });\n\n      if (response.data.success) {\n        const { user, tokens } = response.data.data;\n        \n        // Store tokens and user data\n        setTokensInStorage(tokens);\n        setUserDataInStorage(user);\n\n        dispatch({\n          type: AUTH_ACTIONS.LOGIN_SUCCESS,\n          payload: { user, tokens }\n        });\n\n        return { success: true, message: response.data.message };\n      } else {\n        const error = response.data.error?.message || 'Eroare la autentificare';\n        dispatch({\n          type: AUTH_ACTIONS.LOGIN_FAILURE,\n          payload: { error }\n        });\n        return { success: false, error };\n      }\n    } catch (error) {\n      const errorMessage = error.response?.data?.error?.message || \n                          error.response?.data?.message || \n                          'Eroare de rețea. Verificați conexiunea.';\n      \n      dispatch({\n        type: AUTH_ACTIONS.LOGIN_FAILURE,\n        payload: { error: errorMessage }\n      });\n      \n      return { success: false, error: errorMessage };\n    }\n  };\n\n  // Logout function\n  const logout = async () => {\n    const token = getTokenFromStorage();\n    \n    try {\n      if (token) {\n        // Call logout endpoint to invalidate token on server\n        const authApi = createAuthenticatedApi(token);\n        await authApi.post('/auth/admin/logout');\n      }\n    } catch (error) {\n      console.warn('Logout API call failed:', error.message);\n      // Continue with client-side logout even if server call fails\n    }\n\n    // Clear client-side data\n    clearTokensFromStorage();\n    dispatch({ type: AUTH_ACTIONS.LOGOUT });\n  };\n\n  // Refresh token function\n  const refreshToken = async () => {\n    const refresh_token = getRefreshTokenFromStorage();\n    \n    if (!refresh_token) {\n      dispatch({\n        type: AUTH_ACTIONS.REFRESH_TOKEN_FAILURE,\n        payload: { error: 'Nu există token de reînnoire' }\n      });\n      return false;\n    }\n\n    try {\n      const response = await api.post('/auth/admin/refresh', {\n        refresh_token\n      });\n\n      if (response.data.success) {\n        const tokens = response.data.data;\n        setTokensInStorage(tokens);\n\n        dispatch({\n          type: AUTH_ACTIONS.REFRESH_TOKEN_SUCCESS,\n          payload: { tokens }\n        });\n\n        return true;\n      } else {\n        clearTokensFromStorage();\n        dispatch({\n          type: AUTH_ACTIONS.REFRESH_TOKEN_FAILURE,\n          payload: { error: response.data.error?.message || 'Token invalid' }\n        });\n        return false;\n      }\n    } catch (error) {\n      clearTokensFromStorage();\n      dispatch({\n        type: AUTH_ACTIONS.REFRESH_TOKEN_FAILURE,\n        payload: { error: 'Eroare la reînnoire token' }\n      });\n      return false;\n    }\n  };\n\n  // Verify token function\n  const verifyToken = async (token) => {\n    try {\n      const authApi = createAuthenticatedApi(token);\n      const response = await authApi.post('/auth/admin/verify');\n      \n      return response.data.success && response.data.data.valid;\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // Check authentication status\n  const checkAuthStatus = async () => {\n    dispatch({ type: AUTH_ACTIONS.SET_LOADING, payload: { loading: true } });\n\n    const token = getTokenFromStorage();\n    const userData = getUserDataFromStorage();\n\n    if (!token || !userData) {\n      dispatch({ type: AUTH_ACTIONS.SET_LOADING, payload: { loading: false } });\n      return;\n    }\n\n    // Verify token is still valid\n    const isValid = await verifyToken(token);\n    \n    if (isValid) {\n      // Token is valid, restore authentication state\n      dispatch({\n        type: AUTH_ACTIONS.SET_AUTH_DATA,\n        payload: {\n          user: userData,\n          tokens: { access_token: token, refresh_token: getRefreshTokenFromStorage() }\n        }\n      });\n    } else {\n      // Token is invalid, try to refresh\n      const refreshed = await refreshToken();\n      \n      if (!refreshed) {\n        // Refresh failed, clear everything\n        clearTokensFromStorage();\n        dispatch({ type: AUTH_ACTIONS.LOGOUT });\n      } else {\n        // Refresh succeeded, restore state with updated tokens\n        dispatch({\n          type: AUTH_ACTIONS.SET_AUTH_DATA,\n          payload: {\n            user: userData,\n            tokens: { \n              access_token: getTokenFromStorage(), \n              refresh_token: getRefreshTokenFromStorage() \n            }\n          }\n        });\n      }\n    }\n\n    dispatch({ type: AUTH_ACTIONS.SET_LOADING, payload: { loading: false } });\n  };\n\n  // Clear error function\n  const clearError = () => {\n    dispatch({ type: AUTH_ACTIONS.CLEAR_ERROR });\n  };\n\n  // Get current access token\n  const getToken = () => {\n    return state.tokens?.access_token || getTokenFromStorage();\n  };\n\n  // Check if user has admin role\n  const isAdmin = () => {\n    return state.user?.role === 'admin';\n  };\n\n  // Protected route helper\n  const requireAuth = () => {\n    return state.isAuthenticated && isAdmin();\n  };\n\n  // Setup axios interceptor for automatic token attachment\n  useEffect(() => {\n    const requestInterceptor = api.interceptors.request.use(\n      (config) => {\n        const token = getToken();\n        if (token && config.url?.includes('/admin/')) {\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n        return config;\n      },\n      (error) => Promise.reject(error)\n    );\n\n    const responseInterceptor = api.interceptors.response.use(\n      (response) => response,\n      async (error) => {\n        const originalRequest = error.config;\n\n        // Handle 401 errors for admin routes\n        if (error.response?.status === 401 && \n            originalRequest.url?.includes('/admin/') && \n            !originalRequest._retry) {\n          \n          originalRequest._retry = true;\n\n          // Try to refresh token\n          const refreshed = await refreshToken();\n          \n          if (refreshed) {\n            // Retry original request with new token\n            const newToken = getTokenFromStorage();\n            originalRequest.headers.Authorization = `Bearer ${newToken}`;\n            return api(originalRequest);\n          } else {\n            // Refresh failed, logout user\n            logout();\n          }\n        }\n\n        return Promise.reject(error);\n      }\n    );\n\n    // Cleanup interceptors on unmount\n    return () => {\n      api.interceptors.request.eject(requestInterceptor);\n      api.interceptors.response.eject(responseInterceptor);\n    };\n  }, [state.tokens]);\n\n  // Check authentication status on component mount\n  useEffect(() => {\n    checkAuthStatus();\n  }, []);\n\n  const contextValue = {\n    // State\n    isAuthenticated: state.isAuthenticated,\n    user: state.user,\n    isLoading: state.isLoading,\n    error: state.error,\n    tokens: state.tokens,\n\n    // Actions\n    login,\n    logout,\n    refreshToken,\n    verifyToken,\n    checkAuthStatus,\n    clearError,\n\n    // Utilities\n    getToken,\n    isAdmin,\n    requireAuth\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook to use auth context\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  \n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  \n  return context;\n};\n\nexport default AuthContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}